#!/usr/bin/env python

import sys
sys.dont_write_bytecode = True

import os
import json
import getopt
from subprocess import Popen, PIPE

verbose = False
domain = 'my.1password.com'

def main():
  global verbose
  global domain
  quiet = False
  params = {}

  # TODO - handle arguments here
  # possible arguments
  # - options
  # - domain
  try:
    opts, args = getopt.getopt(sys.argv[1:], 'd:hqv', ['domain=', 'help', 'quiet', 'verbose'])
  except getopt.GetoptError as e:
    usage(e)
    sys.exit(2)
    
  # check opts
  for k, v in opts:
    if k in ['-d', '--domain']:
      domain = v
    elif k in ['-h', '--help']:
      usage()
      sys.exit()
    elif k in ['-q', '--quiet']:
      quiet = True
    elif k in ['-v', '--verbose']:
      verbose = True
    else:
      # should be caught above by except handler
      assert Flase, "unhandled option"
      
  # check args
  if len(args) == 1:
    if verbose:
      print('args: ' + ' '.join(args))
  elif len(args) > 1:
  	usage('Usage error: too many args included (' + len(args) + ')')
  	sys.exit(2)
  else:
    if not quiet:
      print('Enter host in \'host=value\' format followed by a blank line:')
  
  
  # read input from stdin coming from git credentials
  while True:
    line = sys.stdin.readline()
    if line == '\n':
      break
    else:
      line = line.rstrip()
      if verbose:
        print('Input line: ' + line)
      parts = line.split('=')
      if len(parts) == 2:
        params[parts[0]] = parts[1]
  
  
  # check if we have a host param
  if 'host' not in params:
    print('Invalid input: missing host value') 
    sys.exit(1)
  host = params['host']


  # check to see if we have a token in the env
  token = ''
  keys = os.environ.keys()
  for key in keys:
   if key.startswith('OP_SESSION_'):
     token = os.environ[key]
     if verbose:
       print('Found token in env')
    
  
  # if no token found: authenticate and get token
  if token == '':
    if verbose:
      print('No token found')
    (token, err) = opSignin()
    if err:
      handleShellErr(err)
    
  # try to get item, with knowledge it might fail if token expired
  (item, err) = opGetItem(host, token) 
  if err:
    if err.endswith('(ERROR) You are not currently signed in. Please run `op signin --help` for instructions\n'):
      # we had an invalid token
      item = None
      if not quiet:
        print('Expired token found. You can get a new token for with the command:')
        print('    eval $(op signin ' + domain + ')')
      (token, err) = opSignin()
      if err:
        handleShellErr(err)
    else:
      handleShellErr(err)
  
  # if item is defined, parse it
  # else we had invalid token, but should have a valid one now, get item
  if item is not None:
    if verbose:
      print('item is not None')
      print('item: ' + item)
    parseOpItem(item)
  else:
    (item, err) = opGetItem(host, token)
    if err:
        handleShellErr(err)
    parseOpItem(item)
    
  return 0
# end main()


# reusable function for calling CLI executable using /usr/bin/env for path
#   returns stdout and stderr
def doShellCmd(args):
  global verbose
  if verbose:
    print('Running cmd: /usr/bin/env' + ' '.join(args))
  (output, err) = (Popen(['/usr/bin/env'] + args, stdout=PIPE, stderr=PIPE)).communicate()
  return (output, err)


# moved out of main to handle invalid tokens
def opSignin():
  (token, err) = doShellCmd(['op', 'signin', domain, '--output=raw'])
  token = token.rstrip()
  return (token, err)


# moved out of main to handle invalid token
def opGetItem(host, token):
  (item, err) = doShellCmd(['op', 'get', 'item', host, '--session=' + token])
  item = item.rstrip()
  return (item, err)


# parse 1password item
def parseOpItem(item):
  global verbose
  try:
      data = json.loads(item)
  except:
      if verbose:
          print('Error parsing json: ')
      sys.exit(1)
  
  details = data.get('details', None)
  if not details:
      if verbose:
          print('Error parsing json: details')
      sys.exit(1)
  
  fields = details.get('fields', None)
  if fields is None:
      if verbose:
          print('Error parsing json: fields')
      sys.exit(1)
  
  for record in fields:
    if record["designation"] == 'username':
      username = record["value"]
    if record["designation"] == 'password':
      password = record["value"]
  
  if 'username' in locals() and 'password' in locals():
    sys.stdout.write('username='+username+'\npassword='+password+'\n' )
    sys.stdout.flush()
  else:
    if verbose:
      print('Error: no username and password found in json')
# end parseOpItem
      
# print usage and any messages re invalid usage
def usage(msg=None):
  if msg:
    print('\033[91m' + '{}'.format(msg) + '\033[0m\n')
    
  print('''usage: {} [-dhv | --domain=my.1password.com 
                 --help | --verbose ] ITEM

  Utility to automate logging into git using 1Password command line utility.
  Git passes in parameters on stdin, and this utility returns a username and 
  password on stdout if found. See Ref [1] for full details.
  
  Before attempting to sign into 1Password, will check for existing token in 
  the current environment variables and will attempt to use it.
  
  To configure git to use this helper, run the following command:
  
    git config --global credential.helper '1password -q --domain=<domain>'
  
  where domain is the correct domain for your 1Password account.
  
  
  Options
    -d, --domain   the domain (or subdomain) to sign into. Defaults to 'my'
    -h, --help     prints this message
    -q, --quiet    suppresses prompts for input on stdin. Should be used when
                   configured as git credential.helper
    -v, --verbose  prints out verbose (debug) messages
    note: -v should only be used while testing as stand-alone script
    
    returns  0  if item exists
  
  
  References:
    [1] https://git-scm.com/book/en/v2/Git-Tools-Credential-Storage
    [2] https://support.1password.com/command-line-getting-started/
'''.format(os.path.basename(sys.argv[0])))
  return -2

def handleShellErr(err):
  print(err)
  sys.exit(1)  

if __name__ == '__main__':
  sys.exit(main())

